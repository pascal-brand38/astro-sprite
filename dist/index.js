// Copyright (c) Pascal Brand
// MIT License
import fs from 'fs';
import path from 'path';
import crypto from 'crypto';
import sharp from 'sharp';
import { fileURLToPath } from 'url';
const defaultConfig = {
    src: {
        dir: 'assets/astro-sprite',
        extension: '.png',
    },
    dst: {
        spriteFile: 'img/astro-sprite.png',
        cssFile: 'css/astro-sprite.css',
        preloadFile: 'components/SpritePreload.astro',
        cssMainClass: '.astro-sprite',
        cssPrefix: '.astro-sprite-',
        cssSelector: '',
    },
    verbose: true,
};
// read all icons data
async function getIcons(config, srcDir) {
    const dirIcons = path.join(srcDir, config.src.dir);
    let maps = await Promise.all(fs.readdirSync(dirIcons).map(async (file) => {
        const fullName = path.join(dirIcons, file);
        if (fs.statSync(fullName).isFile() && file.endsWith(config.src.extension)) {
            const image = sharp(fullName);
            const metadata = await image.metadata();
            const icon = {
                name: path.parse(file).name,
                fullName,
                width: metadata.width ? metadata.width : 0,
                height: metadata.height ? metadata.height : 0,
            };
            return icon;
        }
        else {
            return undefined;
        }
    }));
    const icons = maps.filter(map => map !== undefined);
    return icons;
}
function verbose(config, text) {
    if (config.verbose) {
        console.log(`[astro-sprite] ${text}`);
    }
}
// get the positions of all icons in the sprite
function getPositions(icons) {
    let positions = [];
    let left = 0;
    icons.forEach(icon => {
        // input, left and top are used by further call to sharp.composite()
        // do not change these property name
        positions.push({ input: icon.fullName, name: icon.name, left: left, top: 0, height: icon.height, width: icon.width });
        left += icon.width;
    });
    return positions;
}
function createDirOfFile(fullName) {
    const dirname = path.dirname(fullName);
    if (!fs.existsSync(dirname)) {
        fs.mkdirSync(dirname, { recursive: true });
    }
}
// write the resulting css
function writeCss(positions, config, srcDir, hash) {
    let cssText = `/* Auto-generated by astro-sprite */\n`;
    cssText += `${config.dst.cssMainClass} { background-image:url(/${config.dst.spriteFile}?v=${hash});}\n`;
    positions.forEach(position => {
        cssText += `${config.dst.cssPrefix}${position.name}${config.dst.cssSelector} { background-position: -${position.left}px -${position.top}px; width: ${position.width}px; height: ${position.height}px; }\n`;
    });
    const cssFile = path.join(srcDir, config.dst.cssFile);
    createDirOfFile(cssFile);
    fs.writeFileSync(cssFile, cssText);
    verbose(config, `Generate ${cssFile}`);
    return cssFile;
}
async function writeSprite(positions, config, publicDir) {
    const getHash = (buffer) => {
        let sha = crypto.createHash('sha256');
        sha.update(buffer);
        return sha.digest("hex").slice(0, 6);
    };
    const sprite = sharp({
        create: {
            background: { alpha: 0, b: 0, g: 0, r: 0 },
            channels: 4,
            height: Math.max(...positions.map(position => position.top + position.height)),
            width: Math.max(...positions.map(position => position.left + position.width)),
        },
    });
    sprite.composite(positions);
    const spriteFile = path.join(publicDir, config.dst.spriteFile);
    createDirOfFile(spriteFile);
    await sprite.toFile(spriteFile);
    const { data, info } = await sprite.toBuffer({ resolveWithObject: true });
    const hash = getHash(data);
    verbose(config, `Generate ${spriteFile}`);
    verbose(config, `         hash=${hash}`);
    return { spriteFile, hash };
}
function writePreload(config, srcDir, hash) {
    if (config.dst.preloadFile) {
        let preloadText = '---\n';
        preloadText += `// Auto-generated by astro-sprite\n`;
        preloadText += '---\n';
        preloadText += `<link rel='preload'   href='/${config.dst.spriteFile}?v=${hash}' as="image" media='all'/>\n`;
        const preloadFile = path.join(srcDir, config.dst.preloadFile);
        createDirOfFile(preloadFile);
        fs.writeFileSync(preloadFile, preloadText);
        verbose(config, `Generate ${preloadFile}`);
        return preloadFile;
    }
    else {
        verbose(config, `No preload component created`);
        return undefined;
    }
}
async function runAstroSprite(config, srcDir, publicDir) {
    const icons = await getIcons(config, srcDir);
    const positions = getPositions(icons);
    const { spriteFile, hash } = await writeSprite(positions, config, publicDir);
    writeCss(positions, config, srcDir, hash);
    writePreload(config, srcDir, hash);
}
// initialize the astro sprite integration
function sprite(config = {}) {
    let spriteConfig = defaultConfig;
    spriteConfig.src = { ...spriteConfig.src, ...config.src };
    spriteConfig.dst = { ...spriteConfig.dst, ...config.dst };
    return {
        name: 'astro-sprite',
        hooks: {
            "astro:config:done": function ({ config: astroConfig }) {
                runAstroSprite(spriteConfig, fileURLToPath(astroConfig.srcDir), fileURLToPath(astroConfig.publicDir));
            },
        },
    };
}
export default sprite;
